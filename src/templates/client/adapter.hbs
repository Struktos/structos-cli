/**
 * {{service}}ClientAdapter
 * 
 * gRPC client adapter for {{service}}Service.
 * Pure TypeScript class - no decorators.
 * Generated by @struktos/cli on {{timestamp}}
 * 
 * Usage:
 *   const client = new {{service}}ClientAdapter(grpcClientFactory);
 *   const result = await client.get(context, id);
 */

import { RequestContext } from '{{coreImports.RequestContext}}';
import { Metadata, credentials, ServiceClientConstructor } from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import * as path from 'path';

/**
 * gRPC Client Factory Interface
 */
export interface IGrpcClientFactory {
  getService<T>(serviceName: string): T;
  createClient<T>(
    protoPath: string,
    packageName: string,
    serviceName: string,
    address: string
  ): T;
}

/**
 * Port interface for {{service}} client operations
 */
export interface I{{service}}ClientPort {
  get(context: RequestContext, id: string): Promise<{{service}}Response>;
  list(context: RequestContext, filter?: {{service}}Filter): Promise<{{service}}ListResponse>;
  create(context: RequestContext, data: Create{{service}}Input): Promise<{{service}}Response>;
  update(context: RequestContext, id: string, data: Update{{service}}Input): Promise<{{service}}Response>;
  delete(context: RequestContext, id: string): Promise<Delete{{service}}Response>;
}

/**
 * {{service}} response DTO
 */
export interface {{service}}Response {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
}

/**
 * Filter options for listing
 */
export interface {{service}}Filter {
  page?: number;
  limit?: number;
  query?: string;
}

/**
 * List response DTO
 */
export interface {{service}}ListResponse {
  items: {{service}}Response[];
  total: number;
  page: number;
  limit: number;
}

/**
 * Create input DTO
 */
export interface Create{{service}}Input {
  name: string;
  description?: string;
}

/**
 * Update input DTO
 */
export interface Update{{service}}Input {
  name?: string;
  description?: string;
}

/**
 * Delete response DTO
 */
export interface Delete{{service}}Response {
  success: boolean;
  message: string;
}

/**
 * {{service}} gRPC Client Adapter
 * 
 * Implements I{{service}}ClientPort using gRPC.
 * Handles context propagation via gRPC metadata.
 */
export class {{service}}ClientAdapter implements I{{service}}ClientPort {
  private {{serviceLower}}Service: any;
  private readonly serviceName = '{{service}}Service';

  /**
   * Create a new {{service}}ClientAdapter
   * 
   * @param grpcClientFactory - Factory for creating gRPC clients
   */
  constructor(
    private readonly grpcClientFactory: IGrpcClientFactory,
  ) {
    this.{{serviceLower}}Service = this.grpcClientFactory.getService('{{service}}');
  }

  /**
   * Create client directly from proto file
   */
  static async createFromProto(
    protoPath: string,
    serviceAddress: string,
    options?: {
      secure?: boolean;
      rootCerts?: Buffer;
    }
  ): Promise<{{service}}ClientAdapter> {
    const packageDefinition = await protoLoader.load(protoPath, {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true,
    });

    const proto = require('@grpc/grpc-js').loadPackageDefinition(packageDefinition);
    const service = (proto as any).{{snakeCase service}}.{{service}}Service;

    const creds = options?.secure
      ? credentials.createSsl(options.rootCerts)
      : credentials.createInsecure();

    const client = new service(serviceAddress, creds);

    const factory: IGrpcClientFactory = {
      getService: () => client,
      createClient: () => client,
    };

    return new {{service}}ClientAdapter(factory);
  }

  /**
   * Get a single {{service}} by ID
   */
  async get(context: RequestContext, id: string): Promise<{{service}}Response> {
    const metadata = this.createMetadata(context);
    const request = { id };

    return new Promise((resolve, reject) => {
      this.{{serviceLower}}Service.Get{{service}}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'get'));
        } else {
          resolve(this.mapResponse(response));
        }
      });
    });
  }

  /**
   * List {{service}}s with optional filtering
   */
  async list(context: RequestContext, filter?: {{service}}Filter): Promise<{{service}}ListResponse> {
    const metadata = this.createMetadata(context);
    const request = {
      page: filter?.page ?? 1,
      limit: filter?.limit ?? 10,
      query: filter?.query ?? '',
    };

    return new Promise((resolve, reject) => {
      this.{{serviceLower}}Service.List{{pluralize service}}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'list'));
        } else {
          resolve({
            items: (response.items || []).map((item: any) => this.mapResponse(item)),
            total: response.total || 0,
            page: response.page || 1,
            limit: response.limit || 10,
          });
        }
      });
    });
  }

  /**
   * Create a new {{service}}
   */
  async create(context: RequestContext, data: Create{{service}}Input): Promise<{{service}}Response> {
    const metadata = this.createMetadata(context);
    const request = { ...data };

    return new Promise((resolve, reject) => {
      this.{{serviceLower}}Service.Create{{service}}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'create'));
        } else {
          resolve(this.mapResponse(response));
        }
      });
    });
  }

  /**
   * Update an existing {{service}}
   */
  async update(
    context: RequestContext,
    id: string,
    data: Update{{service}}Input
  ): Promise<{{service}}Response> {
    const metadata = this.createMetadata(context);
    const request = { id, ...data };

    return new Promise((resolve, reject) => {
      this.{{serviceLower}}Service.Update{{service}}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'update'));
        } else {
          resolve(this.mapResponse(response));
        }
      });
    });
  }

  /**
   * Delete a {{service}}
   */
  async delete(context: RequestContext, id: string): Promise<Delete{{service}}Response> {
    const metadata = this.createMetadata(context);
    const request = { id };

    return new Promise((resolve, reject) => {
      this.{{serviceLower}}Service.Delete{{service}}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'delete'));
        } else {
          resolve({
            success: response.success ?? true,
            message: response.message ?? 'Deleted successfully',
          });
        }
      });
    });
  }

  /**
   * Create gRPC metadata with context propagation
   */
  private createMetadata(context: RequestContext): Metadata {
    const metadata = new Metadata();

    // Propagate trace ID
    const traceId = context.get('traceId');
    if (traceId) {
      metadata.set('x-request-id', traceId);
      metadata.set('x-trace-id', traceId);
    }

    // Propagate user ID
    const userId = context.get('userId');
    if (userId) {
      metadata.set('x-user-id', userId);
    }

    // Propagate authorization
    const auth = context.get('authorization');
    if (auth) {
      metadata.set('authorization', auth);
    }

    // Add custom metadata from context
    const customMetadata = context.get('grpcMetadata');
    if (customMetadata && typeof customMetadata === 'object') {
      for (const [key, value] of Object.entries(customMetadata)) {
        if (typeof value === 'string') {
          metadata.set(key, value);
        }
      }
    }

    return metadata;
  }

  /**
   * Map gRPC response to typed response
   */
  private mapResponse(response: any): {{service}}Response {
    return {
      id: response.id || '',
      name: response.name || '',
      description: response.description,
      createdAt: parseInt(response.created_at || response.createdAt || '0', 10),
      updatedAt: parseInt(response.updated_at || response.updatedAt || '0', 10),
    };
  }

  /**
   * Handle gRPC errors
   */
  private handleError(error: any, operation: string): Error {
    const code = error.code;
    const message = error.message || error.details || 'Unknown gRPC error';

    switch (code) {
      case 5: // NOT_FOUND
        return new Error(`{{service}} not found: ${message}`);
      case 3: // INVALID_ARGUMENT
        return new Error(`Invalid argument for ${operation}: ${message}`);
      case 7: // PERMISSION_DENIED
        return new Error(`Permission denied for ${operation}: ${message}`);
      case 16: // UNAUTHENTICATED
        return new Error(`Authentication required for ${operation}: ${message}`);
      case 14: // UNAVAILABLE
        return new Error(`{{service}}Service unavailable: ${message}`);
      case 4: // DEADLINE_EXCEEDED
        return new Error(`Timeout during ${operation}: ${message}`);
      default:
        return new Error(`gRPC error during ${operation}: ${message} (code: ${code})`);
    }
  }
}

/**
 * Factory function
 */
export function create{{service}}ClientAdapter(
  grpcClientFactory: IGrpcClientFactory
): {{service}}ClientAdapter {
  return new {{service}}ClientAdapter(grpcClientFactory);
}
/**
 * TimingMiddleware
 * 
 * Tracks and reports request timing metrics with configurable thresholds.
 * Generated by @struktos/cli on {{timestamp}}
 */

import { 
  IStruktosMiddleware, 
  MiddlewareContext, 
  NextFunction,
  StruktosContextData 
} from '@struktos/core';

/**
 * Timing configuration options
 */
export interface TimingOptions {
  /** Threshold in ms for warning (default: 1000) */
  warnThresholdMs?: number;
  /** Threshold in ms for critical (default: 5000) */
  errorThresholdMs?: number;
  /** Callback for timing metrics */
  onTiming?: (metrics: TimingMetrics) => void;
  /** Include in response headers */
  addResponseHeader?: boolean;
  /** Response header name */
  headerName?: string;
}

/**
 * Timing metrics structure
 */
export interface TimingMetrics {
  /** Request trace ID */
  traceId: string;
  /** HTTP method */
  method: string;
  /** Request path */
  path: string;
  /** Duration in milliseconds */
  duration: number;
  /** Performance status based on thresholds */
  status: 'ok' | 'slow' | 'critical';
  /** ISO timestamp of when the request completed */
  timestamp: string;
}

/**
 * Timing Middleware
 * 
 * Monitors request duration and reports metrics.
 * Useful for performance monitoring and SLA tracking.
 */
export class TimingMiddleware<T extends StruktosContextData = StruktosContextData> 
  implements IStruktosMiddleware<T> {
  
  private readonly options: Required<TimingOptions>;

  constructor(options: TimingOptions = {}) {
    this.options = {
      warnThresholdMs: options.warnThresholdMs ?? 1000,
      errorThresholdMs: options.errorThresholdMs ?? 5000,
      onTiming: options.onTiming ?? this.defaultTimingHandler.bind(this),
      addResponseHeader: options.addResponseHeader ?? true,
      headerName: options.headerName ?? 'X-Response-Time',
    };
  }

  async invoke(ctx: MiddlewareContext<T>, next: NextFunction): Promise<void> {
    const start = Date.now();
    const traceId = ctx.context.get('traceId' as keyof T) as string || 'unknown';
    const method = ctx.request.method || 'unknown';
    const path = ctx.request.path || 'unknown';

    try {
      await next();
    } finally {
      // Always record timing, even on error
      const duration = Date.now() - start;
      const status = this.getStatus(duration);

      // Add response header if enabled
      if (this.options.addResponseHeader && ctx.response.headers) {
        ctx.response.headers[this.options.headerName] = `${duration}ms`;
      }

      // Report metrics
      const metrics: TimingMetrics = {
        traceId,
        method,
        path,
        duration,
        status,
        timestamp: new Date().toISOString(),
      };

      this.options.onTiming(metrics);
    }
  }

  /**
   * Determine status based on duration and thresholds
   */
  private getStatus(duration: number): 'ok' | 'slow' | 'critical' {
    if (duration >= this.options.errorThresholdMs) return 'critical';
    if (duration >= this.options.warnThresholdMs) return 'slow';
    return 'ok';
  }

  /**
   * Default timing handler - logs to console with colors
   */
  private defaultTimingHandler(metrics: TimingMetrics): void {
    const emoji = metrics.status === 'ok' ? '✓' : metrics.status === 'slow' ? '⚠' : '⛔';
    const color = metrics.status === 'ok' ? '' : metrics.status === 'slow' ? '\x1b[33m' : '\x1b[31m';
    const reset = '\x1b[0m';
    
    console.log(
      `${color}[${emoji}] ${metrics.method} ${metrics.path} - ${metrics.duration}ms (${metrics.status})${reset}`
    );
  }
}

/**
 * Factory function for creating the timing middleware
 */
export function createTimingMiddleware<T extends StruktosContextData = StruktosContextData>(
  options?: TimingOptions
): TimingMiddleware<T> {
  return new TimingMiddleware<T>(options);
}

/**
 * Create a timing middleware with Prometheus-style metrics callback
 */
export function createMetricsTimingMiddleware<T extends StruktosContextData = StruktosContextData>(
  recordMetric: (method: string, path: string, duration: number, status: string) => void
): TimingMiddleware<T> {
  return new TimingMiddleware<T>({
    onTiming: (metrics) => {
      recordMetric(metrics.method, metrics.path, metrics.duration, metrics.status);
    },
  });
}
/**
 * TimingInterceptor
 * 
 * Tracks and reports request timing metrics with configurable thresholds.
 * Generated by @struktos/cli on {{timestamp}}
 */

import { RequestContext, IInterceptor, NextFn } from '{{coreImports.IInterceptor}}';
import { Observable, tap, finalize } from 'rxjs';

/**
 * Timing configuration options
 */
export interface TimingOptions {
  /** Threshold in ms for warning (default: 1000) */
  warnThresholdMs?: number;
  /** Threshold in ms for critical (default: 5000) */
  errorThresholdMs?: number;
  /** Callback for timing metrics */
  onTiming?: (metrics: TimingMetrics) => void;
  /** Include in response headers */
  addResponseHeader?: boolean;
}

/**
 * Timing metrics structure
 */
export interface TimingMetrics {
  /** Request trace ID */
  traceId: string;
  /** HTTP method or gRPC method name */
  method: string;
  /** Request path or route */
  path: string;
  /** Duration in milliseconds */
  duration: number;
  /** Performance status based on thresholds */
  status: 'ok' | 'slow' | 'critical';
  /** ISO timestamp of when the request completed */
  timestamp: string;
}

/**
 * Timing Interceptor
 * 
 * Monitors request duration and reports metrics.
 * Useful for performance monitoring and SLA tracking.
 */
export class TimingInterceptor implements IInterceptor {
  private readonly options: Required<TimingOptions>;

  constructor(options: TimingOptions = {}) {
    this.options = {
      warnThresholdMs: options.warnThresholdMs ?? 1000,
      errorThresholdMs: options.errorThresholdMs ?? 5000,
      onTiming: options.onTiming ?? this.defaultTimingHandler.bind(this),
      addResponseHeader: options.addResponseHeader ?? false,
    };
  }

  intercept(context: RequestContext, next: NextFn): Observable<any> {
    const start = Date.now();
    const traceId = context.get('traceId') || 'unknown';
    const method = context.get('methodName') || context.get('method') || 'unknown';
    const path = context.get('route') || context.get('path') || 'unknown';

    return next().pipe(
      // Add timing header if enabled
      tap(() => {
        if (this.options.addResponseHeader) {
          const res = context.get('response');
          if (res && typeof res.setHeader === 'function') {
            res.setHeader('X-Response-Time', `${Date.now() - start}ms`);
          }
        }
      }),

      // Report metrics on completion (success or error)
      finalize(() => {
        const duration = Date.now() - start;
        const status = this.getStatus(duration);

        const metrics: TimingMetrics = {
          traceId,
          method,
          path,
          duration,
          status,
          timestamp: new Date().toISOString(),
        };

        this.options.onTiming(metrics);
      })
    );
  }

  /**
   * Determine status based on duration and thresholds
   */
  private getStatus(duration: number): 'ok' | 'slow' | 'critical' {
    if (duration >= this.options.errorThresholdMs) return 'critical';
    if (duration >= this.options.warnThresholdMs) return 'slow';
    return 'ok';
  }

  /**
   * Default timing handler - logs to console
   */
  private defaultTimingHandler(metrics: TimingMetrics): void {
    const emoji = metrics.status === 'ok' ? '✓' : metrics.status === 'slow' ? '⚠' : '⛔';
    const color = metrics.status === 'ok' ? '' : metrics.status === 'slow' ? '\x1b[33m' : '\x1b[31m';
    const reset = '\x1b[0m';
    
    console.log(
      `${color}[${emoji}] ${metrics.method} ${metrics.path} - ${metrics.duration}ms (${metrics.status})${reset}`
    );
  }
}

/**
 * Factory function for creating the timing interceptor
 */
export function createTimingInterceptor(options?: TimingOptions): TimingInterceptor {
  return new TimingInterceptor(options);
}

/**
 * Create a timing interceptor with Prometheus-style metrics callback
 */
export function createMetricsTimingInterceptor(
  recordMetric: (method: string, path: string, duration: number, status: string) => void
): TimingInterceptor {
  return new TimingInterceptor({
    onTiming: (metrics) => {
      recordMetric(metrics.method, metrics.path, metrics.duration, metrics.status);
    },
  });
}
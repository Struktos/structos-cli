/**
 * LoggingInterceptor
 * 
 * A comprehensive logging interceptor for request/response tracking.
 * Generated by @struktos/cli on {{timestamp}}
 */

import { RequestContext, IInterceptor, NextFn } from '{{coreImports.IInterceptor}}';
import { Observable, tap, catchError, throwError } from 'rxjs';

/**
 * Logging configuration options
 */
export interface LoggingOptions {
  /** Log incoming requests */
  logRequests?: boolean;
  /** Log outgoing responses */
  logResponses?: boolean;
  /** Log errors */
  logErrors?: boolean;
  /** Include duration in logs */
  logDuration?: boolean;
  /** Fields to redact from logs */
  sensitiveFields?: string[];
  /** Custom log function */
  logFn?: (message: string) => void;
}

/**
 * Log entry structure
 */
export interface LogEntry {
  level: 'info' | 'error' | 'warn' | 'debug';
  type: 'request' | 'response' | 'error';
  traceId: string;
  method: string;
  path: string;
  duration?: number;
  timestamp: string;
  error?: string;
  stack?: string;
}

/**
 * Logging Interceptor
 * 
 * Provides structured logging for all requests and responses.
 * Supports sensitive field redaction and configurable log levels.
 */
export class LoggingInterceptor implements IInterceptor {
  private readonly options: Required<LoggingOptions>;

  constructor(options: LoggingOptions = {}) {
    this.options = {
      logRequests: options.logRequests ?? true,
      logResponses: options.logResponses ?? true,
      logErrors: options.logErrors ?? true,
      logDuration: options.logDuration ?? true,
      sensitiveFields: options.sensitiveFields ?? ['password', 'token', 'secret', 'apiKey', 'authorization'],
      logFn: options.logFn ?? console.log,
    };
  }

  intercept(context: RequestContext, next: NextFn): Observable<any> {
    const start = Date.now();
    const traceId = context.get('traceId') || 'unknown';
    const method = context.get('methodName') || context.get('method') || 'unknown';
    const path = context.get('route') || context.get('path') || 'unknown';

    // Log request
    if (this.options.logRequests) {
      this.log({
        level: 'info',
        type: 'request',
        traceId,
        method,
        path,
        timestamp: new Date().toISOString(),
      });
    }

    return next().pipe(
      // Log response
      tap((response) => {
        if (this.options.logResponses) {
          const duration = Date.now() - start;
          this.log({
            level: 'info',
            type: 'response',
            traceId,
            method,
            path,
            duration: this.options.logDuration ? duration : undefined,
            timestamp: new Date().toISOString(),
          });
        }
      }),

      // Log errors
      catchError((error) => {
        if (this.options.logErrors) {
          const duration = Date.now() - start;
          this.log({
            level: 'error',
            type: 'error',
            traceId,
            method,
            path,
            error: error.message,
            stack: error.stack,
            duration: this.options.logDuration ? duration : undefined,
            timestamp: new Date().toISOString(),
          });
        }
        return throwError(() => error);
      })
    );
  }

  /**
   * Log a structured entry
   */
  private log(entry: LogEntry): void {
    this.options.logFn(JSON.stringify(entry));
  }

  /**
   * Sanitize an object by redacting sensitive fields
   */
  private sanitize<T extends Record<string, unknown>>(obj: T): T {
    if (!obj || typeof obj !== 'object') return obj;
    
    const sanitized = { ...obj };
    for (const field of this.options.sensitiveFields) {
      if (field in sanitized) {
        (sanitized as Record<string, unknown>)[field] = '[REDACTED]';
      }
    }
    return sanitized;
  }
}

/**
 * Factory function for creating the logging interceptor
 */
export function createLoggingInterceptor(options?: LoggingOptions): LoggingInterceptor {
  return new LoggingInterceptor(options);
}
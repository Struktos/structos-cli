/**
 * LoggingMiddleware
 * 
 * A comprehensive logging middleware for request/response tracking.
 * Generated by @struktos/cli on {{timestamp}}
 */

import { 
  IStruktosMiddleware, 
  MiddlewareContext, 
  NextFunction,
  StruktosContextData 
} from '@struktos/core';

/**
 * Logging configuration options
 */
export interface LoggingOptions {
  /** Log incoming requests */
  logRequests?: boolean;
  /** Log outgoing responses */
  logResponses?: boolean;
  /** Log errors */
  logErrors?: boolean;
  /** Include duration in logs */
  logDuration?: boolean;
  /** Fields to redact from logs */
  sensitiveFields?: string[];
  /** Custom log function */
  logFn?: (entry: LogEntry) => void;
}

/**
 * Log entry structure
 */
export interface LogEntry {
  level: 'info' | 'error' | 'warn' | 'debug';
  type: 'request' | 'response' | 'error';
  traceId: string;
  method: string;
  path: string;
  duration?: number;
  timestamp: string;
  statusCode?: number;
  error?: string;
  stack?: string;
}

/**
 * Logging Middleware
 * 
 * Provides structured logging for all requests and responses.
 * Supports sensitive field redaction and configurable log levels.
 */
export class LoggingMiddleware<T extends StruktosContextData = StruktosContextData> 
  implements IStruktosMiddleware<T> {
  
  private readonly options: Required<LoggingOptions>;

  constructor(options: LoggingOptions = {}) {
    this.options = {
      logRequests: options.logRequests ?? true,
      logResponses: options.logResponses ?? true,
      logErrors: options.logErrors ?? true,
      logDuration: options.logDuration ?? true,
      sensitiveFields: options.sensitiveFields ?? ['password', 'token', 'secret', 'apiKey', 'authorization'],
      logFn: options.logFn ?? this.defaultLogFn,
    };
  }

  async invoke(ctx: MiddlewareContext<T>, next: NextFunction): Promise<void> {
    const start = Date.now();
    const traceId = ctx.context.get('traceId' as keyof T) as string || 'unknown';
    const method = ctx.request.method || 'unknown';
    const path = ctx.request.path || 'unknown';

    // Log request
    if (this.options.logRequests) {
      this.log({
        level: 'info',
        type: 'request',
        traceId,
        method,
        path,
        timestamp: new Date().toISOString(),
      });
    }

    try {
      await next();

      // Log response
      if (this.options.logResponses) {
        const duration = Date.now() - start;
        this.log({
          level: 'info',
          type: 'response',
          traceId,
          method,
          path,
          statusCode: ctx.response.status,
          duration: this.options.logDuration ? duration : undefined,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      // Log errors
      if (this.options.logErrors) {
        const duration = Date.now() - start;
        const err = error instanceof Error ? error : new Error(String(error));
        this.log({
          level: 'error',
          type: 'error',
          traceId,
          method,
          path,
          error: err.message,
          stack: err.stack,
          duration: this.options.logDuration ? duration : undefined,
          timestamp: new Date().toISOString(),
        });
      }
      throw error;
    }
  }

  /**
   * Log a structured entry
   */
  private log(entry: LogEntry): void {
    this.options.logFn(entry);
  }

  /**
   * Default log function - outputs JSON to console
   */
  private defaultLogFn(entry: LogEntry): void {
    console.log(JSON.stringify(entry));
  }

  /**
   * Sanitize an object by redacting sensitive fields
   */
  private sanitize<O extends Record<string, unknown>>(obj: O): O {
    if (!obj || typeof obj !== 'object') return obj;
    
    const sanitized = { ...obj };
    for (const field of this.options.sensitiveFields) {
      if (field in sanitized) {
        (sanitized as Record<string, unknown>)[field] = '[REDACTED]';
      }
    }
    return sanitized;
  }
}

/**
 * Factory function for creating the logging middleware
 */
export function createLoggingMiddleware<T extends StruktosContextData = StruktosContextData>(
  options?: LoggingOptions
): LoggingMiddleware<T> {
  return new LoggingMiddleware<T>(options);
}
/**
 * {{action}}{{entity}}UseCase
 * 
 * Use case for {{actionLower}}ing {{entityLower}} entities.
 * Pure TypeScript class - no decorators.
 * Generated by @struktos/cli on {{timestamp}}
 * 
 * Usage:
 *   const useCase = new {{action}}{{entity}}UseCase({{#if needsRepository}}repository{{#if needsLogger}}, {{/if}}{{/if}}{{#if needsLogger}}logger{{/if}});
 *   const result = await useCase.execute(context, input);
 */

import { RequestContext{{#if needsLogger}}, ILogger{{/if}} } from '{{coreImports.RequestContext}}';
{{#if needsRepository}}
import { I{{entity}}Repository } from '{{repositoryImportPath}}';
import { {{entity}} } from '{{entityImportPath}}';
{{/if}}

/**
 * Input DTO for {{action}}{{entity}}UseCase
 */
export interface {{action}}{{entity}}Input {
{{#if (eq actionLower "create")}}
  /** Name of the {{entityLower}} */
  name: string;
  /** Optional description */
  description?: string;
  /** Additional fields */
  [key: string]: unknown;
{{else if (eq actionLower "get")}}
  /** ID of the {{entityLower}} to retrieve */
  id: string;
{{else if (eq actionLower "find")}}
  /** ID of the {{entityLower}} to find */
  id: string;
{{else if (eq actionLower "list")}}
  /** Page number (1-indexed) */
  page?: number;
  /** Items per page */
  limit?: number;
  /** Filter criteria */
  filter?: Record<string, unknown>;
  /** Sort field */
  sortBy?: string;
  /** Sort direction */
  sortOrder?: 'asc' | 'desc';
{{else if (eq actionLower "search")}}
  /** Search query */
  query: string;
  /** Page number */
  page?: number;
  /** Items per page */
  limit?: number;
{{else if (eq actionLower "update")}}
  /** ID of the {{entityLower}} to update */
  id: string;
  /** Fields to update */
  data: Partial<{
    name?: string;
    description?: string;
    [key: string]: unknown;
  }>;
{{else if (eq actionLower "delete")}}
  /** ID of the {{entityLower}} to delete */
  id: string;
  /** Use soft delete */
  soft?: boolean;
{{else}}
  /** Input data */
  data: unknown;
{{/if}}
}

/**
 * Output DTO for {{action}}{{entity}}UseCase
 */
export interface {{action}}{{entity}}Output {
{{#if (eq actionLower "create")}}
  /** The created {{entityLower}} */
  {{entityLower}}: {
    id: string;
    name: string;
    description?: string;
    createdAt: Date;
    updatedAt: Date;
  };
{{else if (or (eq actionLower "get") (eq actionLower "find") (eq actionLower "update"))}}
  /** The {{entityLower}} entity */
  {{entityLower}}: {
    id: string;
    name: string;
    description?: string;
    createdAt: Date;
    updatedAt: Date;
  };
{{else if (or (eq actionLower "list") (eq actionLower "search"))}}
  /** List of {{entityLower}}s */
  items: Array<{
    id: string;
    name: string;
    createdAt: Date;
    updatedAt: Date;
  }>;
  /** Total count */
  total: number;
  /** Current page */
  page: number;
  /** Items per page */
  limit: number;
  /** Has more pages */
  hasMore: boolean;
{{else if (eq actionLower "delete")}}
  /** Operation success */
  success: boolean;
  /** Deleted entity ID */
  deletedId: string;
  /** Deletion timestamp */
  deletedAt: Date;
{{else}}
  /** Operation result */
  success: boolean;
  /** Result data */
  data?: unknown;
{{/if}}
}

/**
 * {{action}}{{entity}}UseCase
 * 
 * Business logic for {{actionLower}}ing {{entityLower}}.
 * Implements the application layer use case pattern.
 */
export class {{action}}{{entity}}UseCase {
  /**
   * Create a new {{action}}{{entity}}UseCase instance
{{#if needsRepository}}
   * @param {{entityLower}}Repository - Repository for {{entity}} persistence
{{/if}}
{{#if needsLogger}}
   * @param logger - Logger instance
{{/if}}
   */
  constructor(
{{#if needsRepository}}
    private readonly {{entityLower}}Repository: I{{entity}}Repository,
{{/if}}
{{#if needsLogger}}
    private readonly logger: ILogger,
{{/if}}
  ) {}

  /**
   * Execute the use case
   * 
   * @param context - Request context with trace ID and metadata
   * @param input - Input data for the operation
   * @returns Promise resolving to the output
   * @throws Error if validation fails or operation cannot be completed
   */
  async execute(
    context: RequestContext,
    input: {{action}}{{entity}}Input
  ): Promise<{{action}}{{entity}}Output> {
    const traceId = context.get('traceId');
{{#if needsLogger}}

    this.logger.info(`[{{action}}{{entity}}UseCase] Starting {{actionLower}} operation`, {
      traceId,
      input: this.sanitizeInput(input),
    });
{{/if}}

    try {
{{#if needsValidation}}
      // Validate input
      this.validate(input);

{{/if}}
{{#if (eq actionLower "create")}}
      // Create entity
{{#if needsRepository}}
      // Use entity's static create factory (auto-generates ID and timestamps)
      const entity = {{entity}}.create(input);

      const saved = await this.{{entityLower}}Repository.create(entity);

      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: saved.toObject() as {{action}}{{entity}}Output['{{entityLower}}'],
      };
{{else}}
      // TODO: Implement create logic
      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: {
          id: crypto.randomUUID(),
          name: input.name,
          description: input.description,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      };
{{/if}}
{{else if (or (eq actionLower "get") (eq actionLower "find"))}}
      // Find entity by ID
{{#if needsRepository}}
      const entity = await this.{{entityLower}}Repository.findById(input.id);

      if (!entity) {
        throw new Error(`{{entity}} not found: ${input.id}`);
      }

      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: entity.toObject() as {{action}}{{entity}}Output['{{entityLower}}'],
      };
{{else}}
      // TODO: Implement find logic
      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: {
          id: input.id,
          name: '{{entity}} Name',
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      };
{{/if}}
{{else if (or (eq actionLower "list") (eq actionLower "search"))}}
      // Get paginated list
      const page = input.page ?? 1;
      const limit = input.limit ?? 10;
{{#if needsRepository}}

      const entities = await this.{{entityLower}}Repository.findAll();
      
      // Apply pagination
      const start = (page - 1) * limit;
      const items = entities.slice(start, start + limit);

      const result: {{action}}{{entity}}Output = {
        items: items.map(e => e.toObject() as {{action}}{{entity}}Output['items'][number]),
        total: entities.length,
        page,
        limit,
        hasMore: start + limit < entities.length,
      };
{{else}}
      // TODO: Implement list logic
      const result: {{action}}{{entity}}Output = {
        items: [],
        total: 0,
        page,
        limit,
        hasMore: false,
      };
{{/if}}
{{else if (eq actionLower "update")}}
      // Update entity
{{#if needsRepository}}
      const existing = await this.{{entityLower}}Repository.findById(input.id);

      if (!existing) {
        throw new Error(`{{entity}} not found: ${input.id}`);
      }

      const updated = {
        ...existing.toObject(),
        ...input.data,
        updatedAt: new Date(),
      };

      const saved = await this.{{entityLower}}Repository.update(
        {{entity}}.fromObject(updated)
      );

      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: saved.toObject() as {{action}}{{entity}}Output['{{entityLower}}'],
      };
{{else}}
      // TODO: Implement update logic
      const result: {{action}}{{entity}}Output = {
        {{entityLower}}: {
          id: input.id,
          name: input.data.name ?? '{{entity}} Name',
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      };
{{/if}}
{{else if (eq actionLower "delete")}}
      // Delete entity
{{#if needsRepository}}
      const existing = await this.{{entityLower}}Repository.findById(input.id);

      if (!existing) {
        throw new Error(`{{entity}} not found: ${input.id}`);
      }

      const deleted = await this.{{entityLower}}Repository.delete(input.id);

      const result: {{action}}{{entity}}Output = {
        success: deleted,
        deletedId: input.id,
        deletedAt: new Date(),
      };
{{else}}
      // TODO: Implement delete logic
      const result: {{action}}{{entity}}Output = {
        success: true,
        deletedId: input.id,
        deletedAt: new Date(),
      };
{{/if}}
{{else}}
      // TODO: Implement {{actionLower}} logic
      const result: {{action}}{{entity}}Output = {
        success: true,
        data: input,
      };
{{/if}}
{{#if needsLogger}}

      this.logger.info(`[{{action}}{{entity}}UseCase] {{action}} operation completed`, {
        traceId,
        result: 'success',
      });
{{/if}}

      return result;
    } catch (error) {
{{#if needsLogger}}
      this.logger.error(`[{{action}}{{entity}}UseCase] {{action}} operation failed`, {
        traceId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });

{{/if}}
      throw error;
    }
  }
{{#if needsValidation}}

  /**
   * Validate input data
   */
  private validate(input: {{action}}{{entity}}Input): void {
{{#if (eq actionLower "create")}}
    if (!input.name || typeof input.name !== 'string') {
      throw new Error('Name is required and must be a string');
    }
    if (input.name.length < 1 || input.name.length > 255) {
      throw new Error('Name must be between 1 and 255 characters');
    }
{{else if (or (eq actionLower "get") (eq actionLower "find") (eq actionLower "delete"))}}
    if (!input.id || typeof input.id !== 'string') {
      throw new Error('ID is required and must be a string');
    }
{{else if (eq actionLower "update")}}
    if (!input.id || typeof input.id !== 'string') {
      throw new Error('ID is required and must be a string');
    }
    if (!input.data || typeof input.data !== 'object') {
      throw new Error('Update data is required');
    }
{{else if (or (eq actionLower "list") (eq actionLower "search"))}}
    if (input.page !== undefined && (input.page < 1 || !Number.isInteger(input.page))) {
      throw new Error('Page must be a positive integer');
    }
    if (input.limit !== undefined && (input.limit < 1 || input.limit > 100)) {
      throw new Error('Limit must be between 1 and 100');
    }
{{else}}
    // TODO: Add validation logic for {{actionLower}}
{{/if}}
  }
{{/if}}
{{#if needsLogger}}

  /**
   * Sanitize input for logging (remove sensitive fields)
   */
  private sanitizeInput(input: {{action}}{{entity}}Input): Record<string, unknown> {
    const sanitized = { ...input } as Record<string, unknown>;
    const sensitiveFields = ['password', 'token', 'secret', 'apiKey'];
    for (const field of sensitiveFields) {
      if (field in sanitized) {
        sanitized[field] = '[REDACTED]';
      }
    }
    return sanitized;
  }
{{/if}}
}

/**
 * Factory function for creating the use case
 */
export function create{{action}}{{entity}}UseCase(
{{#if needsRepository}}
  {{entityLower}}Repository: I{{entity}}Repository,
{{/if}}
{{#if needsLogger}}
  logger: ILogger,
{{/if}}
): {{action}}{{entity}}UseCase {
  return new {{action}}{{entity}}UseCase(
{{#if needsRepository}}
    {{entityLower}}Repository,
{{/if}}
{{#if needsLogger}}
    logger,
{{/if}}
  );
}
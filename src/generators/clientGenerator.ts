/**
 * gRPC Client Adapter Generator
 * 
 * Generates pure TypeScript gRPC client adapter classes without decorators.
 * Includes context propagation and trace ID handling.
 */

import { toPascalCase, toCamelCase, toKebabCase, toSnakeCase } from '../utils/fieldParser';

/**
 * Generate a gRPC client adapter
 */
export function generateGrpcClientAdapter(serviceName: string): string {
  const className = toPascalCase(serviceName);
  const camelName = toCamelCase(serviceName);
  const kebabName = toKebabCase(serviceName);
  const snakeName = toSnakeCase(serviceName);

  return `/**
 * ${className}ClientAdapter
 * 
 * gRPC client adapter for ${className}Service.
 * Pure TypeScript class - no decorators.
 * Generated by @struktos/cli
 * 
 * Usage:
 *   const client = new ${className}ClientAdapter(grpcClientFactory);
 *   const result = await client.get(context, id);
 */

import { RequestContext } from '@struktos/core';
import { Metadata, credentials, ServiceClientConstructor } from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import * as path from 'path';

/**
 * gRPC Client Factory Interface
 * Used to create and manage gRPC service clients
 */
export interface IGrpcClientFactory {
  getService<T>(serviceName: string): T;
  createClient<T>(
    protoPath: string,
    packageName: string,
    serviceName: string,
    address: string
  ): T;
}

/**
 * Port interface for ${className} client operations
 */
export interface I${className}ClientPort {
  get(context: RequestContext, id: string): Promise<${className}Response>;
  list(context: RequestContext, filter?: ${className}Filter): Promise<${className}ListResponse>;
  create(context: RequestContext, data: Create${className}Input): Promise<${className}Response>;
  update(context: RequestContext, id: string, data: Update${className}Input): Promise<${className}Response>;
  delete(context: RequestContext, id: string): Promise<Delete${className}Response>;
}

/**
 * DTOs for ${className} operations
 */
export interface ${className}Response {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  updatedAt: number;
}

export interface ${className}Filter {
  page?: number;
  limit?: number;
  query?: string;
}

export interface ${className}ListResponse {
  items: ${className}Response[];
  total: number;
  page: number;
  limit: number;
}

export interface Create${className}Input {
  name: string;
  description?: string;
}

export interface Update${className}Input {
  name?: string;
  description?: string;
}

export interface Delete${className}Response {
  success: boolean;
  message: string;
}

/**
 * ${className} gRPC Client Adapter
 * 
 * Implements the ${className}ClientPort interface using gRPC.
 * Handles context propagation via gRPC metadata.
 */
export class ${className}ClientAdapter implements I${className}ClientPort {
  private ${camelName}Service: any;
  private readonly serviceName = '${className}Service';

  /**
   * Create a new ${className}ClientAdapter
   * 
   * @param grpcClientFactory - Factory for creating gRPC clients
   */
  constructor(
    private readonly grpcClientFactory: IGrpcClientFactory,
  ) {
    // Get the gRPC service client from the factory
    this.${camelName}Service = this.grpcClientFactory.getService('${className}');
  }

  /**
   * Alternative constructor that creates the client directly from proto
   */
  static async createFromProto(
    protoPath: string,
    serviceAddress: string,
    options?: {
      secure?: boolean;
      rootCerts?: Buffer;
    }
  ): Promise<${className}ClientAdapter> {
    const packageDefinition = await protoLoader.load(protoPath, {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true,
    });

    const proto = require('@grpc/grpc-js').loadPackageDefinition(packageDefinition);
    const service = (proto as any).${snakeName}.${className}Service;

    const creds = options?.secure
      ? credentials.createSsl(options.rootCerts)
      : credentials.createInsecure();

    const client = new service(serviceAddress, creds);

    // Create a mock factory that returns this client
    const factory: IGrpcClientFactory = {
      getService: () => client,
      createClient: () => client,
    };

    return new ${className}ClientAdapter(factory);
  }

  /**
   * Get a single ${className} by ID
   */
  async get(context: RequestContext, id: string): Promise<${className}Response> {
    const metadata = this.createMetadata(context);
    const request = { id };

    return new Promise((resolve, reject) => {
      this.${camelName}Service.Get${className}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'get'));
        } else {
          resolve(this.map${className}Response(response));
        }
      });
    });
  }

  /**
   * List ${className}s with optional filtering
   */
  async list(context: RequestContext, filter?: ${className}Filter): Promise<${className}ListResponse> {
    const metadata = this.createMetadata(context);
    const request = {
      page: filter?.page ?? 1,
      limit: filter?.limit ?? 10,
      query: filter?.query ?? '',
    };

    return new Promise((resolve, reject) => {
      this.${camelName}Service.List${className}s(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'list'));
        } else {
          resolve({
            items: (response.items || []).map((item: any) => this.map${className}Response(item)),
            total: response.total || 0,
            page: response.page || 1,
            limit: response.limit || 10,
          });
        }
      });
    });
  }

  /**
   * Create a new ${className}
   */
  async create(context: RequestContext, data: Create${className}Input): Promise<${className}Response> {
    const metadata = this.createMetadata(context);
    const request = { ...data };

    return new Promise((resolve, reject) => {
      this.${camelName}Service.Create${className}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'create'));
        } else {
          resolve(this.map${className}Response(response));
        }
      });
    });
  }

  /**
   * Update an existing ${className}
   */
  async update(
    context: RequestContext,
    id: string,
    data: Update${className}Input
  ): Promise<${className}Response> {
    const metadata = this.createMetadata(context);
    const request = { id, ...data };

    return new Promise((resolve, reject) => {
      this.${camelName}Service.Update${className}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'update'));
        } else {
          resolve(this.map${className}Response(response));
        }
      });
    });
  }

  /**
   * Delete a ${className}
   */
  async delete(context: RequestContext, id: string): Promise<Delete${className}Response> {
    const metadata = this.createMetadata(context);
    const request = { id };

    return new Promise((resolve, reject) => {
      this.${camelName}Service.Delete${className}(request, metadata, (error: any, response: any) => {
        if (error) {
          reject(this.handleError(error, 'delete'));
        } else {
          resolve({
            success: response.success ?? true,
            message: response.message ?? 'Deleted successfully',
          });
        }
      });
    });
  }

  /**
   * Create gRPC metadata with context propagation
   * Injects trace ID and other context values into metadata
   */
  private createMetadata(context: RequestContext): Metadata {
    const metadata = new Metadata();

    // Propagate trace ID for distributed tracing
    const traceId = context.get('traceId');
    if (traceId) {
      metadata.set('x-request-id', traceId);
      metadata.set('x-trace-id', traceId);
    }

    // Propagate user ID if available
    const userId = context.get('userId');
    if (userId) {
      metadata.set('x-user-id', userId);
    }

    // Propagate authorization if available
    const auth = context.get('authorization');
    if (auth) {
      metadata.set('authorization', auth);
    }

    // Add custom metadata from context
    const customMetadata = context.get('grpcMetadata');
    if (customMetadata && typeof customMetadata === 'object') {
      for (const [key, value] of Object.entries(customMetadata)) {
        if (typeof value === 'string') {
          metadata.set(key, value);
        }
      }
    }

    return metadata;
  }

  /**
   * Map gRPC response to typed response
   */
  private map${className}Response(response: any): ${className}Response {
    return {
      id: response.id || '',
      name: response.name || '',
      description: response.description,
      createdAt: parseInt(response.created_at || response.createdAt || '0', 10),
      updatedAt: parseInt(response.updated_at || response.updatedAt || '0', 10),
    };
  }

  /**
   * Handle gRPC errors and convert to application errors
   */
  private handleError(error: any, operation: string): Error {
    const code = error.code;
    const message = error.message || error.details || 'Unknown gRPC error';

    // Map gRPC status codes to meaningful errors
    switch (code) {
      case 5: // NOT_FOUND
        return new Error(\`${className} not found: \${message}\`);
      case 3: // INVALID_ARGUMENT
        return new Error(\`Invalid argument for \${operation}: \${message}\`);
      case 7: // PERMISSION_DENIED
        return new Error(\`Permission denied for \${operation}: \${message}\`);
      case 16: // UNAUTHENTICATED
        return new Error(\`Authentication required for \${operation}: \${message}\`);
      case 14: // UNAVAILABLE
        return new Error(\`${className}Service unavailable: \${message}\`);
      case 4: // DEADLINE_EXCEEDED
        return new Error(\`Timeout during \${operation}: \${message}\`);
      default:
        return new Error(\`gRPC error during \${operation}: \${message} (code: \${code})\`);
    }
  }
}

/**
 * Factory function for creating the client adapter
 */
export function create${className}ClientAdapter(
  grpcClientFactory: IGrpcClientFactory
): ${className}ClientAdapter {
  return new ${className}ClientAdapter(grpcClientFactory);
}
`;
}

/**
 * Generate the client port interface file separately
 */
export function generateClientPortInterface(serviceName: string): string {
  const className = toPascalCase(serviceName);
  const camelName = toCamelCase(serviceName);

  return `/**
 * I${className}ClientPort
 * 
 * Port interface for ${className} client operations.
 * Part of the application layer in Hexagonal Architecture.
 * Generated by @struktos/cli
 */

import { RequestContext } from '@struktos/core';

/**
 * ${className} entity representation
 */
export interface ${className}Dto {
  id: string;
  name: string;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Filter options for listing ${className}s
 */
export interface ${className}FilterDto {
  page?: number;
  limit?: number;
  query?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Paginated list response
 */
export interface ${className}ListDto {
  items: ${className}Dto[];
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;
}

/**
 * Input for creating a new ${className}
 */
export interface Create${className}Dto {
  name: string;
  description?: string;
}

/**
 * Input for updating an existing ${className}
 */
export interface Update${className}Dto {
  name?: string;
  description?: string;
}

/**
 * Port interface for ${className} client
 * 
 * This interface defines the contract for accessing ${className} data
 * from external services (e.g., via gRPC, REST, etc.)
 */
export interface I${className}ClientPort {
  /**
   * Get a single ${className} by ID
   * 
   * @param context - Request context with trace ID
   * @param id - The ${className} ID
   * @returns The ${className} or throws if not found
   */
  get(context: RequestContext, id: string): Promise<${className}Dto>;

  /**
   * List ${className}s with optional filtering
   * 
   * @param context - Request context with trace ID
   * @param filter - Optional filter and pagination options
   * @returns Paginated list of ${className}s
   */
  list(context: RequestContext, filter?: ${className}FilterDto): Promise<${className}ListDto>;

  /**
   * Create a new ${className}
   * 
   * @param context - Request context with trace ID
   * @param data - The ${className} data to create
   * @returns The created ${className}
   */
  create(context: RequestContext, data: Create${className}Dto): Promise<${className}Dto>;

  /**
   * Update an existing ${className}
   * 
   * @param context - Request context with trace ID
   * @param id - The ${className} ID to update
   * @param data - The fields to update
   * @returns The updated ${className}
   */
  update(context: RequestContext, id: string, data: Update${className}Dto): Promise<${className}Dto>;

  /**
   * Delete a ${className}
   * 
   * @param context - Request context with trace ID
   * @param id - The ${className} ID to delete
   * @returns True if deleted successfully
   */
  delete(context: RequestContext, id: string): Promise<boolean>;
}
`;
}
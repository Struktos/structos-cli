/**
 * @struktos/cli - gRPC Service Generator
 */

import { toPascalCase, toCamelCase, toKebabCase, toSnakeCase, pluralize } from '../utils/fieldParser';

/**
 * Generate .proto file content
 */
export function generateProtoFile(serviceName: string, methods: string[]): string {
  const pascal = toPascalCase(serviceName);
  const snake = toSnakeCase(serviceName);
  const plural = pluralize(pascal);

  const methodDefinitions = methods.map((method) => {
    switch (method) {
      case 'get':
        return `  // Get a single ${pascal} by ID
  rpc Get${pascal} (Get${pascal}Request) returns (${pascal});`;
      case 'list':
        return `  // List all ${plural} with pagination
  rpc List${plural} (List${plural}Request) returns (stream ${pascal});`;
      case 'create':
        return `  // Create a new ${pascal}
  rpc Create${pascal} (Create${pascal}Request) returns (${pascal});`;
      case 'update':
        return `  // Update an existing ${pascal}
  rpc Update${pascal} (Update${pascal}Request) returns (${pascal});`;
      case 'delete':
        return `  // Delete a ${pascal}
  rpc Delete${pascal} (Delete${pascal}Request) returns (Delete${pascal}Response);`;
      default:
        return '';
    }
  }).filter(Boolean).join('\n\n');

  const messageDefinitions = generateMessageDefinitions(serviceName, methods);

  return `syntax = "proto3";

package ${snake};

option go_package = "./${snake}";

// ${pascal} Service
// Generated by @struktos/cli
service ${pascal}Service {
${methodDefinitions}
}

${messageDefinitions}
`;
}

/**
 * Generate message definitions for proto file
 */
function generateMessageDefinitions(serviceName: string, methods: string[]): string {
  const pascal = toPascalCase(serviceName);
  const plural = pluralize(pascal);
  const messages: string[] = [];

  // Main entity message
  messages.push(`// ${pascal} entity
message ${pascal} {
  string id = 1;
  string name = 2;
  string description = 3;
  int64 created_at = 4;
  int64 updated_at = 5;
}`);

  if (methods.includes('get')) {
    messages.push(`// Get${pascal} request
message Get${pascal}Request {
  string id = 1;
}`);
  }

  if (methods.includes('list')) {
    messages.push(`// List${plural} request
message List${plural}Request {
  int32 page_size = 1;
  string page_token = 2;
}`);
  }

  if (methods.includes('create')) {
    messages.push(`// Create${pascal} request
message Create${pascal}Request {
  string name = 1;
  string description = 2;
}`);
  }

  if (methods.includes('update')) {
    messages.push(`// Update${pascal} request
message Update${pascal}Request {
  string id = 1;
  string name = 2;
  string description = 3;
}`);
  }

  if (methods.includes('delete')) {
    messages.push(`// Delete${pascal} request
message Delete${pascal}Request {
  string id = 1;
}

// Delete${pascal} response
message Delete${pascal}Response {
  bool success = 1;
  string message = 2;
}`);
  }

  return messages.join('\n\n');
}

/**
 * Generate gRPC service handler file
 */
export function generateGrpcServiceHandler(serviceName: string, methods: string[]): string {
  const pascal = toPascalCase(serviceName);
  const camel = toCamelCase(serviceName);
  const kebab = toKebabCase(serviceName);
  const plural = pluralize(pascal);
  const pluralCamel = pluralize(camel);

  const methodImplementations = methods.map((method) => {
    switch (method) {
      case 'get':
        return `  /**
   * Get a single ${pascal} by ID
   */
  Get${pascal}: (call: any, callback: any) => {
    const ctx = RequestContext.current<GrpcContextData>();
    const traceId = ctx?.get('traceId');
    const { id } = call.request;

    console.log(\`[Get${pascal}] id=\${id}, trace=\${traceId}\`);

    // TODO: Implement actual logic using use case
    const ${camel} = {
      id,
      name: 'Sample ${pascal}',
      description: 'Sample description',
      created_at: Date.now(),
      updated_at: Date.now(),
    };

    callback(null, ${camel});
  },`;

      case 'list':
        return `  /**
   * List all ${plural} with server streaming
   */
  List${plural}: (call: any) => {
    const ctx = RequestContext.current<GrpcContextData>();
    const traceId = ctx?.get('traceId');
    const { page_size = 10 } = call.request;

    console.log(\`[List${plural}] page_size=\${page_size}, trace=\${traceId}\`);

    // TODO: Implement actual logic using use case
    const ${pluralCamel} = Array.from({ length: Math.min(page_size, 5) }, (_, i) => ({
      id: \`${camel}-\${i + 1}\`,
      name: \`${pascal} \${i + 1}\`,
      description: \`Description for ${camel} \${i + 1}\`,
      created_at: Date.now() - i * 86400000,
      updated_at: Date.now(),
    }));

    for (const ${camel} of ${pluralCamel}) {
      call.write(${camel});
    }
    call.end();
  },`;

      case 'create':
        return `  /**
   * Create a new ${pascal}
   */
  Create${pascal}: (call: any, callback: any) => {
    const ctx = RequestContext.current<GrpcContextData>();
    const traceId = ctx?.get('traceId');
    const { name, description } = call.request;

    console.log(\`[Create${pascal}] name=\${name}, trace=\${traceId}\`);

    // TODO: Implement actual logic using use case
    const ${camel} = {
      id: \`${camel}-\${Date.now()}\`,
      name,
      description,
      created_at: Date.now(),
      updated_at: Date.now(),
    };

    callback(null, ${camel});
  },`;

      case 'update':
        return `  /**
   * Update an existing ${pascal}
   */
  Update${pascal}: (call: any, callback: any) => {
    const ctx = RequestContext.current<GrpcContextData>();
    const traceId = ctx?.get('traceId');
    const { id, name, description } = call.request;

    console.log(\`[Update${pascal}] id=\${id}, trace=\${traceId}\`);

    // TODO: Implement actual logic using use case
    const ${camel} = {
      id,
      name,
      description,
      created_at: Date.now() - 86400000,
      updated_at: Date.now(),
    };

    callback(null, ${camel});
  },`;

      case 'delete':
        return `  /**
   * Delete a ${pascal}
   */
  Delete${pascal}: (call: any, callback: any) => {
    const ctx = RequestContext.current<GrpcContextData>();
    const traceId = ctx?.get('traceId');
    const { id } = call.request;

    console.log(\`[Delete${pascal}] id=\${id}, trace=\${traceId}\`);

    // TODO: Implement actual logic using use case
    callback(null, {
      success: true,
      message: \`${pascal} \${id} deleted successfully\`,
    });
  },`;

      default:
        return '';
    }
  }).filter(Boolean).join('\n\n');

  return `/**
 * ${pascal} gRPC Service Handler
 * 
 * Generated by @struktos/cli
 * 
 * This file contains the gRPC service implementation for ${pascal}.
 * Integrate with your domain use cases to implement business logic.
 */

import { RequestContext } from '@struktos/core';
import { GrpcContextData } from '@struktos/adapter-grpc';

/**
 * ${pascal} service implementation
 * 
 * @example
 * \`\`\`typescript
 * import { ${camel}Service } from './${kebab}.service.grpc';
 * 
 * await adapter.addProtoService(
 *   './protos/${kebab}.proto',
 *   '${toSnakeCase(serviceName)}.${pascal}Service',
 *   ${camel}Service
 * );
 * \`\`\`
 */
export const ${camel}Service = {
${methodImplementations}
};

/**
 * Register ${pascal} service with gRPC adapter
 */
export async function register${pascal}Service(adapter: any, protoPath: string): Promise<void> {
  await adapter.addProtoService(
    protoPath,
    '${toSnakeCase(serviceName)}.${pascal}Service',
    ${camel}Service
  );
  console.log(\`[gRPC] ${pascal}Service registered\`);
}
`;
}

/**
 * Generate service registration example
 */
export function generateServiceRegistration(serviceName: string): string {
  const pascal = toPascalCase(serviceName);
  const camel = toCamelCase(serviceName);
  const kebab = toKebabCase(serviceName);

  return `/**
 * ${pascal} Service Registration Example
 * 
 * Add this to your main.ts or app.ts to register the ${pascal} gRPC service.
 */

import * as path from 'path';
import { GrpcStruktosAdapter, createGrpcAdapter } from '@struktos/adapter-grpc';
import { register${pascal}Service } from './${kebab}.service.grpc';

/**
 * Register all gRPC services
 * Call this function in your main.ts before starting the server
 */
export async function register${pascal}GrpcService(adapter: GrpcStruktosAdapter): Promise<void> {
  // Proto file is located at project root /protos directory
  const protoPath = path.join(process.cwd(), 'protos/${kebab}.proto');
  
  await register${pascal}Service(adapter, protoPath);
}

// Example usage in main.ts:
/*
import { StruktosApp } from '@struktos/core';
import { createGrpcAdapter } from '@struktos/adapter-grpc';
import { register${pascal}GrpcService } from './infrastructure/adapters/grpc/${kebab}.registration';

async function main() {
  const app = StruktosApp.create({ name: '${kebab}-service' });
  
  const adapter = createGrpcAdapter({
    enableCancellation: true,
  });
  
  await register${pascal}GrpcService(adapter);
  
  await app.listen(adapter, 50051);
  console.log('gRPC server running on port 50051');
}

main().catch(console.error);
*/
`;
}
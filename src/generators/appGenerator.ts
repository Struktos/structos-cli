/**
 * @struktos/cli - Application Generator
 */

import { ProjectConfig, ADAPTERS } from '../types';

/**
 * Generate main.ts for HTTP frameworks (Express, Fastify, NestJS)
 */
export function generateHttpMain(config: ProjectConfig): string {
  const adapterInfo = ADAPTERS[config.framework];
  
  let adapterImport = '';
  let adapterCreate = '';
  let frameworkSetup = '';

  if (config.framework === 'express') {
    adapterImport = `import { ExpressStruktosAdapter } from '@struktos/adapter-express';
import express from 'express';`;
    frameworkSetup = `
  // Create Express app
  const expressApp = express();
  expressApp.use(express.json());`;
    adapterCreate = `const adapter = new ExpressStruktosAdapter(expressApp);`;
  } else if (config.framework === 'fastify') {
    adapterImport = `import { FastifyStruktosAdapter } from '@struktos/adapter-fastify';
import Fastify from 'fastify';`;
    frameworkSetup = `
  // Create Fastify instance
  const fastify = Fastify({ logger: true });`;
    adapterCreate = `const adapter = new FastifyStruktosAdapter(fastify);`;
  } else if (config.framework === 'nestjs') {
    adapterImport = `import { NestStruktosAdapter } from '@struktos/adapter-nestjs';`;
    adapterCreate = `const adapter = new NestStruktosAdapter();`;
  }

  const authImport = config.useAuth
    ? `import { AuthMiddleware, JwtService } from '@struktos/auth';`
    : '';

  const authSetup = config.useAuth
    ? `
  // Setup authentication
  const jwtService = new JwtService({
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: '1h',
  });
  app.use(new AuthMiddleware(jwtService));`
    : '';

  return `/**
 * ${config.name} - Main Application Entry
 * 
 * Generated by @struktos/cli
 * Framework: ${adapterInfo.name}
 */

import {
  StruktosApp,
  RequestContext,
  LoggingMiddleware,
  TimingMiddleware,
} from '@struktos/core';
${adapterImport}
${authImport}

const PORT = parseInt(process.env.PORT || '${adapterInfo.defaultPort}', 10);

async function main() {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('  ${config.name}');
  console.log('  Framework: ${adapterInfo.name}');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n');
${frameworkSetup}

  // Create Struktos application
  const app = StruktosApp.create({
    name: '${config.name}',
    useDefaultErrorHandler: true,
  });

  // Add middlewares
  app
    .use(new LoggingMiddleware())
    .use(new TimingMiddleware());
${authSetup}

  // Create adapter
  ${adapterCreate}

  // Setup routes
  setupRoutes(adapter);

  // Start server
  const serverInfo = await app.listen(adapter, PORT);
  
  console.log(\`ğŸš€ Server started!\`);
  console.log(\`   URL: \${serverInfo.url}\`);
  console.log(\`   Protocol: \${serverInfo.protocol}\\n\`);
  console.log('Press Ctrl+C to stop\\n');

  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\\nShutting down...');
    await app.stop();
    console.log('Server stopped');
    process.exit(0);
  });
}

/**
 * Setup application routes
 */
function setupRoutes(adapter: any): void {
  // Health check
  adapter.get?.('/health', (req: any, res: any) => {
    const ctx = RequestContext.current();
    res.json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      traceId: ctx?.get('traceId'),
    });
  });

  // Welcome route
  adapter.get?.('/', (req: any, res: any) => {
    res.json({
      message: 'Welcome to ${config.name}!',
      version: '1.0.0',
      docs: '/api/docs',
    });
  });

  // TODO: Add your routes here
}

// Run application
main().catch((error) => {
  console.error('Failed to start application:', error);
  process.exit(1);
});
`;
}

/**
 * Generate main.ts for gRPC framework
 */
export function generateGrpcMain(config: ProjectConfig): string {
  const authImport = config.useAuth
    ? `import { AuthMiddleware, JwtService } from '@struktos/auth';`
    : '';

  const authSetup = config.useAuth
    ? `
  // Setup authentication middleware
  const jwtService = new JwtService({
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: '1h',
  });
  // Note: For gRPC, auth is typically handled via metadata
  // app.use(createAuthInterceptor(jwtService));`
    : '';

  return `/**
 * ${config.name} - gRPC Microservice Entry
 * 
 * Generated by @struktos/cli
 * Protocol: gRPC
 */

import * as path from 'path';
import {
  StruktosApp,
  RequestContext,
} from '@struktos/core';
import {
  createGrpcAdapter,
  createLoggingInterceptor,
  createTimeoutInterceptor,
  GrpcContextData,
} from '@struktos/adapter-grpc';
${authImport}

const PORT = parseInt(process.env.GRPC_PORT || '50051', 10);
const HOST = process.env.GRPC_HOST || '0.0.0.0';

async function main() {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('  ${config.name} - gRPC Microservice');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\\n');

  // Create Struktos application
  const app = StruktosApp.create<GrpcContextData>({
    name: '${config.name}',
    useDefaultErrorHandler: true,
  });

  // Add middlewares (interceptors for gRPC)
  app
    .use(createLoggingInterceptor({ logRequests: true, logResponses: true }))
    .use(createTimeoutInterceptor(30000)); // 30 second timeout
${authSetup}

  // Create gRPC adapter
  const adapter = createGrpcAdapter({
    name: '${config.name}-grpc',
    enableCancellation: true,
    onContextCreated: (ctx, _call) => {
      console.log(\`[Context] Created for \${ctx.methodPath}\`);
    },
    onRequestComplete: (ctx, duration) => {
      console.log(\`[Context] Completed \${ctx.methodPath} in \${duration}ms\`);
    },
  });

  // Register gRPC services
  await registerServices(adapter);

  // Start gRPC server
  const serverInfo = await app.listen(adapter, PORT, HOST);

  console.log(\`ğŸš€ gRPC Server started!\`);
  console.log(\`   Address: \${serverInfo.url}\`);
  console.log(\`   Protocol: \${serverInfo.protocol}\`);
  console.log(\`   Services: \${serverInfo.metadata?.services?.join(', ') || 'none'}\\n\`);
  console.log('Press Ctrl+C to stop\\n');

  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\\nShutting down...');
    await app.stop();
    console.log('gRPC server stopped');
    process.exit(0);
  });
}

/**
 * Register gRPC services
 * 
 * Add your service registrations here.
 * Use \`struktos generate service <name> --type=grpc\` to generate new services.
 */
async function registerServices(adapter: any): Promise<void> {
  // Example: Health check service (inline for demonstration)
  const healthService = {
    Check: (call: any, callback: any) => {
      const ctx = RequestContext.current<GrpcContextData>();
      console.log(\`[Health] Check called, trace: \${ctx?.get('traceId')}\`);
      callback(null, { status: 1 }); // SERVING
    },
  };

  // TODO: Register your services here
  // Example:
  // const protoPath = path.join(__dirname, '../protos/user.proto');
  // await adapter.addProtoService(protoPath, 'user.UserService', userService);

  console.log('[gRPC] Services registered');
}

// Run application
main().catch((error) => {
  console.error('Failed to start gRPC server:', error);
  process.exit(1);
});
`;
}

/**
 * Generate main.ts based on framework selection
 */
export function generateMainTs(config: ProjectConfig): string {
  if (config.framework === 'grpc') {
    return generateGrpcMain(config);
  }
  return generateHttpMain(config);
}
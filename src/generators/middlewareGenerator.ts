/**
 * Middleware (Interceptor) Generator
 * 
 * Generates pure TypeScript class interceptors without decorators.
 */

import { toPascalCase, toCamelCase, toKebabCase } from '../utils/fieldParser';

/**
 * Generate a middleware/interceptor file
 */
export function generateMiddleware(name: string): string {
  const className = toPascalCase(name);
  const camelName = toCamelCase(name);

  return `/**
 * ${className}Interceptor
 * 
 * A pure TypeScript interceptor class implementing IInterceptor.
 * Generated by @struktos/cli
 * 
 * Usage:
 *   app.use(new ${className}Interceptor());
 */

import { RequestContext, IInterceptor, NextFn } from '@struktos/core';
import { Observable, tap, catchError, throwError } from 'rxjs';

/**
 * ${className} Interceptor
 * 
 * Intercepts requests and responses in the middleware pipeline.
 * No decorators - pure TypeScript class.
 */
export class ${className}Interceptor implements IInterceptor {
  private readonly name = '${className}Interceptor';

  /**
   * Constructor for dependency injection
   * 
   * @param logger - Optional logger instance
   */
  constructor(
    // Inject dependencies via constructor if needed
    // private readonly logger?: ILogger,
  ) {}

  /**
   * Intercept the request/response flow
   * 
   * @param context - The request context with trace ID and metadata
   * @param next - Function to call the next handler in the chain
   * @returns Observable of the response
   */
  intercept(context: RequestContext, next: NextFn): Observable<any> {
    const start = Date.now();
    const traceId = context.get('traceId') || 'unknown';
    const methodName = context.get('methodName') || context.get('route') || 'unknown';

    // Pre-processing
    console.log(\`[\${this.name}] [START] \${methodName} (Trace: \${traceId})\`);

    return next().pipe(
      // Post-processing on success
      tap((response) => {
        const duration = Date.now() - start;
        console.log(\`[\${this.name}] [END] \${methodName} completed in \${duration}ms\`);
        
        // TODO: Add your success handling logic here
        // Examples:
        // - Log response metrics
        // - Update monitoring systems
        // - Cache response
      }),

      // Error handling
      catchError((error) => {
        const duration = Date.now() - start;
        console.error(\`[\${this.name}] [ERROR] \${methodName} failed after \${duration}ms:\`, error.message);
        
        // TODO: Add your error handling logic here
        // Examples:
        // - Log error to monitoring service
        // - Transform error response
        // - Trigger alerts
        
        return throwError(() => error);
      })
    );
  }
}

/**
 * Factory function for creating the interceptor
 * Useful when you need to pass configuration
 */
export function create${className}Interceptor(options?: {
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
  includePayload?: boolean;
}): ${className}Interceptor {
  return new ${className}Interceptor();
}
`;
}

/**
 * Generate logging interceptor template
 */
export function generateLoggingMiddleware(): string {
  return `/**
 * LoggingInterceptor
 * 
 * A comprehensive logging interceptor for request/response tracking.
 * Generated by @struktos/cli
 */

import { RequestContext, IInterceptor, NextFn } from '@struktos/core';
import { Observable, tap, catchError, throwError } from 'rxjs';

export interface LoggingOptions {
  logRequests?: boolean;
  logResponses?: boolean;
  logErrors?: boolean;
  logDuration?: boolean;
  sensitiveFields?: string[];
}

export class LoggingInterceptor implements IInterceptor {
  private readonly options: Required<LoggingOptions>;

  constructor(options: LoggingOptions = {}) {
    this.options = {
      logRequests: options.logRequests ?? true,
      logResponses: options.logResponses ?? true,
      logErrors: options.logErrors ?? true,
      logDuration: options.logDuration ?? true,
      sensitiveFields: options.sensitiveFields ?? ['password', 'token', 'secret'],
    };
  }

  intercept(context: RequestContext, next: NextFn): Observable<any> {
    const start = Date.now();
    const traceId = context.get('traceId');
    const method = context.get('methodName') || context.get('method');
    const path = context.get('route') || context.get('path');

    if (this.options.logRequests) {
      console.log(JSON.stringify({
        level: 'info',
        type: 'request',
        traceId,
        method,
        path,
        timestamp: new Date().toISOString(),
      }));
    }

    return next().pipe(
      tap((response) => {
        if (this.options.logResponses) {
          const duration = Date.now() - start;
          console.log(JSON.stringify({
            level: 'info',
            type: 'response',
            traceId,
            method,
            path,
            duration: this.options.logDuration ? duration : undefined,
            timestamp: new Date().toISOString(),
          }));
        }
      }),
      catchError((error) => {
        if (this.options.logErrors) {
          const duration = Date.now() - start;
          console.error(JSON.stringify({
            level: 'error',
            type: 'error',
            traceId,
            method,
            path,
            error: error.message,
            stack: error.stack,
            duration: this.options.logDuration ? duration : undefined,
            timestamp: new Date().toISOString(),
          }));
        }
        return throwError(() => error);
      })
    );
  }

  private sanitize(obj: any): any {
    if (!obj || typeof obj !== 'object') return obj;
    const sanitized = { ...obj };
    for (const field of this.options.sensitiveFields) {
      if (field in sanitized) {
        sanitized[field] = '[REDACTED]';
      }
    }
    return sanitized;
  }
}

export function createLoggingInterceptor(options?: LoggingOptions): LoggingInterceptor {
  return new LoggingInterceptor(options);
}
`;
}

/**
 * Generate timing interceptor template
 */
export function generateTimingMiddleware(): string {
  return `/**
 * TimingInterceptor
 * 
 * Tracks and reports request timing metrics.
 * Generated by @struktos/cli
 */

import { RequestContext, IInterceptor, NextFn } from '@struktos/core';
import { Observable, tap, finalize } from 'rxjs';

export interface TimingOptions {
  warnThresholdMs?: number;
  errorThresholdMs?: number;
  onTiming?: (metrics: TimingMetrics) => void;
}

export interface TimingMetrics {
  traceId: string;
  method: string;
  path: string;
  duration: number;
  status: 'ok' | 'slow' | 'critical';
}

export class TimingInterceptor implements IInterceptor {
  private readonly options: Required<TimingOptions>;

  constructor(options: TimingOptions = {}) {
    this.options = {
      warnThresholdMs: options.warnThresholdMs ?? 1000,
      errorThresholdMs: options.errorThresholdMs ?? 5000,
      onTiming: options.onTiming ?? this.defaultTimingHandler,
    };
  }

  intercept(context: RequestContext, next: NextFn): Observable<any> {
    const start = Date.now();
    const traceId = context.get('traceId') || 'unknown';
    const method = context.get('methodName') || context.get('method') || 'unknown';
    const path = context.get('route') || context.get('path') || 'unknown';

    return next().pipe(
      finalize(() => {
        const duration = Date.now() - start;
        const status = this.getStatus(duration);

        const metrics: TimingMetrics = {
          traceId,
          method,
          path,
          duration,
          status,
        };

        this.options.onTiming(metrics);
      })
    );
  }

  private getStatus(duration: number): 'ok' | 'slow' | 'critical' {
    if (duration >= this.options.errorThresholdMs) return 'critical';
    if (duration >= this.options.warnThresholdMs) return 'slow';
    return 'ok';
  }

  private defaultTimingHandler(metrics: TimingMetrics): void {
    const emoji = metrics.status === 'ok' ? '✓' : metrics.status === 'slow' ? '⚠' : '⛔';
    console.log(\`[\${emoji}] \${metrics.method} \${metrics.path} - \${metrics.duration}ms (\${metrics.status})\`);
  }
}

export function createTimingInterceptor(options?: TimingOptions): TimingInterceptor {
  return new TimingInterceptor(options);
}
`;
}
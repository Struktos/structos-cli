/**
 * Use Case Generator
 * 
 * Generates pure TypeScript use case classes without decorators.
 * Follows Clean Architecture / Hexagonal Architecture patterns.
 */

import { toPascalCase, toCamelCase, toKebabCase } from '../utils/fieldParser';

export type UseCaseAction = 
  | 'create' 
  | 'get' 
  | 'list' 
  | 'update' 
  | 'delete' 
  | 'find'
  | 'search'
  | 'validate'
  | 'process'
  | 'execute';

/**
 * Generate a use case file
 */
export function generateUseCase(
  action: string,
  entityName: string,
  options: {
    withRepository?: boolean;
    withLogger?: boolean;
    withValidation?: boolean;
  } = {}
): string {
  const actionPascal = toPascalCase(action);
  const entityPascal = toPascalCase(entityName);
  const entityCamel = toCamelCase(entityName);
  const actionCamel = toCamelCase(action);
  
  const className = `${actionPascal}${entityPascal}UseCase`;
  const { withRepository = true, withLogger = true, withValidation = true } = options;

  // Determine return type and implementation based on action
  const { returnType, implementation } = getActionImplementation(action, entityPascal, entityCamel);

  const imports: string[] = [
    "import { RequestContext } from '@struktos/core';",
  ];

  const constructorParams: string[] = [];
  const constructorDocs: string[] = [];

  if (withRepository) {
    imports.push(`import { I${entityPascal}Repository } from '../../domain/repositories/I${entityPascal}Repository';`);
    imports.push(`import { ${entityPascal} } from '../../domain/entities/${entityPascal}.entity';`);
    constructorParams.push(`private readonly ${entityCamel}Repository: I${entityPascal}Repository`);
    constructorDocs.push(`   * @param ${entityCamel}Repository - Repository for ${entityPascal} entity`);
  }

  if (withLogger) {
    imports.push(`import { ILogger } from '@struktos/core';`);
    constructorParams.push(`private readonly logger: ILogger`);
    constructorDocs.push(`   * @param logger - Logger instance for tracking operations`);
  }

  const constructorParamsStr = constructorParams.length > 0 
    ? constructorParams.join(',\n    ') 
    : '';

  const constructorDocsStr = constructorDocs.length > 0
    ? `\n${constructorDocs.join('\n')}`
    : '';

  return `/**
 * ${className}
 * 
 * Use case for ${action}ing ${entityName} entities.
 * Pure TypeScript class - no decorators.
 * Generated by @struktos/cli
 * 
 * Usage:
 *   const useCase = new ${className}(repository, logger);
 *   const result = await useCase.execute(context, payload);
 */

${imports.join('\n')}

/**
 * Input DTO for ${className}
 */
export interface ${actionPascal}${entityPascal}Input {
${getInputFields(action, entityPascal)}
}

/**
 * Output DTO for ${className}
 */
export interface ${actionPascal}${entityPascal}Output {
${getOutputFields(action, entityPascal)}
}

/**
 * ${className}
 * 
 * Business logic for ${action}ing ${entityName}.
 * Implements the application layer use case pattern.
 */
export class ${className} {
  /**
   * Create a new ${className} instance
   *${constructorDocsStr}
   */
  constructor(
    ${constructorParamsStr}
  ) {}

  /**
   * Execute the use case
   * 
   * @param context - Request context with trace ID and metadata
   * @param input - Input data for the operation
   * @returns ${returnType}
   * @throws Error if validation fails or operation cannot be completed
   */
  async execute(
    context: RequestContext,
    input: ${actionPascal}${entityPascal}Input
  ): Promise<${actionPascal}${entityPascal}Output> {
    const traceId = context.get('traceId');
${withLogger ? `    
    this.logger.info(\`[${className}] Starting ${action} operation\`, {
      traceId,
      input: this.sanitizeInput(input),
    });
` : ''}
    try {
${withValidation ? `      // Validate input
      this.validate(input);
` : ''}
${implementation}
${withLogger ? `
      this.logger.info(\`[${className}] ${actionPascal} operation completed\`, {
        traceId,
        result: 'success',
      });
` : ''}
      return result;
    } catch (error) {
${withLogger ? `      this.logger.error(\`[${className}] ${actionPascal} operation failed\`, {
        traceId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
` : ''}
      throw error;
    }
  }
${withValidation ? `
  /**
   * Validate input data
   */
  private validate(input: ${actionPascal}${entityPascal}Input): void {
    // TODO: Add validation logic
${getValidationLogic(action, entityPascal)}
  }
` : ''}
${withLogger ? `
  /**
   * Sanitize input for logging (remove sensitive fields)
   */
  private sanitizeInput(input: ${actionPascal}${entityPascal}Input): Record<string, unknown> {
    const sanitized = { ...input } as Record<string, unknown>;
    // Remove sensitive fields before logging
    const sensitiveFields = ['password', 'token', 'secret', 'apiKey'];
    for (const field of sensitiveFields) {
      if (field in sanitized) {
        sanitized[field] = '[REDACTED]';
      }
    }
    return sanitized;
  }
` : ''}
}

/**
 * Factory function for creating the use case with dependencies
 */
export function create${className}(
${constructorParams.map(p => `  ${p}`).join(',\n')}
): ${className} {
  return new ${className}(
    ${constructorParams.map(p => p.split(':')[0].replace('private readonly ', '').trim()).join(',\n    ')}
  );
}
`;
}

function getInputFields(action: string, entityName: string): string {
  switch (action.toLowerCase()) {
    case 'create':
      return `  // Required fields for creating a new ${entityName}
  name: string;
  // TODO: Add other required fields
  [key: string]: unknown;`;
    case 'get':
    case 'find':
      return `  // ID of the ${entityName} to retrieve
  id: string;`;
    case 'list':
    case 'search':
      return `  // Pagination
  page?: number;
  limit?: number;
  // Filters
  filter?: Record<string, unknown>;
  // Sorting
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';`;
    case 'update':
      return `  // ID of the ${entityName} to update
  id: string;
  // Fields to update
  data: Partial<{
    name: string;
    // TODO: Add other updatable fields
    [key: string]: unknown;
  }>;`;
    case 'delete':
      return `  // ID of the ${entityName} to delete
  id: string;
  // Soft delete flag
  soft?: boolean;`;
    default:
      return `  // Input data
  data: unknown;`;
  }
}

function getOutputFields(action: string, entityName: string): string {
  switch (action.toLowerCase()) {
    case 'create':
    case 'get':
    case 'find':
    case 'update':
      return `  // The ${entityName} entity
  ${entityName.toLowerCase()}: {
    id: string;
    name: string;
    createdAt: Date;
    updatedAt: Date;
    // TODO: Add other fields
  };`;
    case 'list':
    case 'search':
      return `  // List of ${entityName} entities
  items: Array<{
    id: string;
    name: string;
    createdAt: Date;
    updatedAt: Date;
  }>;
  // Pagination info
  total: number;
  page: number;
  limit: number;
  hasMore: boolean;`;
    case 'delete':
      return `  // Deletion result
  success: boolean;
  deletedId: string;
  deletedAt: Date;`;
    default:
      return `  // Operation result
  success: boolean;
  data?: unknown;`;
  }
}

function getActionImplementation(
  action: string, 
  entityName: string,
  entityCamel: string
): { returnType: string; implementation: string } {
  switch (action.toLowerCase()) {
    case 'create':
      return {
        returnType: `Created ${entityName}`,
        implementation: `      // Create entity
      const entity = ${entityName}.create({
        ...input,
        id: crypto.randomUUID(),
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Save to repository
      const saved = await this.${entityCamel}Repository.create(entity);

      const result: ${toPascalCase(action)}${entityName}Output = {
        ${entityCamel}: saved.toObject(),
      };`,
      };
    case 'get':
    case 'find':
      return {
        returnType: `${entityName} or null`,
        implementation: `      // Find entity by ID
      const entity = await this.${entityCamel}Repository.findById(input.id);

      if (!entity) {
        throw new Error(\`${entityName} not found: \${input.id}\`);
      }

      const result: ${toPascalCase(action)}${entityName}Output = {
        ${entityCamel}: entity.toObject(),
      };`,
      };
    case 'list':
    case 'search':
      return {
        returnType: `List of ${entityName}`,
        implementation: `      // Get paginated list
      const page = input.page ?? 1;
      const limit = input.limit ?? 10;

      const entities = await this.${entityCamel}Repository.findAll();
      
      // Apply pagination (simplified)
      const start = (page - 1) * limit;
      const items = entities.slice(start, start + limit);

      const result: ${toPascalCase(action)}${entityName}Output = {
        items: items.map(e => e.toObject()),
        total: entities.length,
        page,
        limit,
        hasMore: start + limit < entities.length,
      };`,
      };
    case 'update':
      return {
        returnType: `Updated ${entityName}`,
        implementation: `      // Find existing entity
      const existing = await this.${entityCamel}Repository.findById(input.id);

      if (!existing) {
        throw new Error(\`${entityName} not found: \${input.id}\`);
      }

      // Update entity
      const updated = {
        ...existing.toObject(),
        ...input.data,
        updatedAt: new Date(),
      };

      const saved = await this.${entityCamel}Repository.update(
        ${entityName}.fromObject(updated)
      );

      const result: ${toPascalCase(action)}${entityName}Output = {
        ${entityCamel}: saved.toObject(),
      };`,
      };
    case 'delete':
      return {
        returnType: `Deletion result`,
        implementation: `      // Check if entity exists
      const existing = await this.${entityCamel}Repository.findById(input.id);

      if (!existing) {
        throw new Error(\`${entityName} not found: \${input.id}\`);
      }

      // Delete entity
      const deleted = await this.${entityCamel}Repository.delete(input.id);

      const result: ${toPascalCase(action)}${entityName}Output = {
        success: deleted,
        deletedId: input.id,
        deletedAt: new Date(),
      };`,
      };
    default:
      return {
        returnType: `Operation result`,
        implementation: `      // TODO: Implement ${action} logic
      const result: ${toPascalCase(action)}${entityName}Output = {
        success: true,
        data: input,
      };`,
      };
  }
}

function getValidationLogic(action: string, entityName: string): string {
  switch (action.toLowerCase()) {
    case 'create':
      return `    if (!input.name || typeof input.name !== 'string') {
      throw new Error('Name is required and must be a string');
    }
    if (input.name.length < 1 || input.name.length > 255) {
      throw new Error('Name must be between 1 and 255 characters');
    }`;
    case 'get':
    case 'find':
    case 'delete':
      return `    if (!input.id || typeof input.id !== 'string') {
      throw new Error('ID is required and must be a string');
    }`;
    case 'update':
      return `    if (!input.id || typeof input.id !== 'string') {
      throw new Error('ID is required and must be a string');
    }
    if (!input.data || typeof input.data !== 'object') {
      throw new Error('Update data is required');
    }`;
    case 'list':
    case 'search':
      return `    if (input.page !== undefined && (input.page < 1 || !Number.isInteger(input.page))) {
      throw new Error('Page must be a positive integer');
    }
    if (input.limit !== undefined && (input.limit < 1 || input.limit > 100)) {
      throw new Error('Limit must be between 1 and 100');
    }`;
    default:
      return `    // TODO: Add validation logic for ${action}`;
  }
}